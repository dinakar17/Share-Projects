//  postsSlice : Piece of State that stores all the posts

// Step 1: Import CreateSlice
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import * as api from "../../../api/index";
import { Details, SearchQuery } from "../../../types";


// Step 2: Initialize initialState
const initialState = {
  loading: false,
  posts: [] as Object[],
  error: "",
};

// Step 3: Create the *Async action creators* using CreateAsyncThunk Function and export them in order to dispatch them i.e., dispatch(fetchPosts())

// Read in CRUD
export const fetchPosts = createAsyncThunk("posts/fetchPosts", async () => {
  // response: {data: {[{title: "", category: "", description: "", github: "", image: ""}, ....]}, status: 200}
  // or response: {data: {message: error.message}, status: 404}
  const response = await api.fetchPosts();
  return response.data; // Now refer to extraReducers
});

export const getProjectsBySearch  = createAsyncThunk("posts/getProjectsBySearch", async (searchQuery: SearchQuery) => {
  // response: {data: {[{title: "", category: "", description: "", github: "", image: ""}, ....]}, status: 200}
  // or response: {data: {message: error.message}, status: 404}
  const response = await api.fetchPostsBySearch(searchQuery);
  return response.data;
})

// Create in CRUD
// Note: Details: (parameter) is the data that comes from the Frontend(React) i.e., dispatch(getPosts(details))
// createPost asynchronous action creator goes through 3 stages: pending, fulfilled, rejected 
export const createPost = createAsyncThunk(
  "posts/createPost",
  async (details: Object) => {
    // response: {data: {title: "", category:"", description:"", github:"", image:""}, status: 201}
    // or  response: {data: {message: error.message}, status: 409}
    const response = await api.createPost(details);
    return response.data;
  }
);

// Delete in CRUD
export const deletePost = createAsyncThunk(
  "posts/deletePost",
  async (id: string) => {
    // response: {data: No post with id ...., status: 404}
    // or response: {data: {message: "Post deleted successfully"}, status: 200}
    // However we're not interested in the response
    await api.deletePost(id);
  }
);

// Update in CRUD
export const updatePost = createAsyncThunk(
  "posts/updatePost",
  async (toBeUpdatedData: { id: String; details: Details }) => {
    const { id, details } = toBeUpdatedData;
    // response: {data: "No post with id: ...", status: 404}
    //or  response: {data: {title: "", category: "", description: "", github: "", image: ""}, status: 200}}
    // However we're not interested in the response 
    await api.updatePost(id, details);
  }
);

// Step 4: Create the Slice (piece of State) 
const postsSlice = createSlice({
  name: "posts",
  initialState,
  reducers: {},

  // extraReducers key is used only when we have to perform some asynchronous actions
  extraReducers: (builder) => {
    builder.addCase(createPost.pending, (state) => {
      // With the help of this one we can set a *loader* while the action is going on...
      state.loading = true;
    });
    
    builder.addCase(createPost.fulfilled, (state, action) => {
      state.loading = false;
      // return response.data is caught by action.payload i.e., action.payload = response.data
      state.posts.push(action.payload);
    });
    builder.addCase(createPost.rejected, (state, action) => {
      state.loading = false;
      state.posts = [];
      // action.error.message could be anything(autogenerated error) that reflects problem in createPost() function
      state.error = action.error.message as string;
    });

    builder.addCase(fetchPosts.pending, (state) => {
      // With the help of this one we can set a *loader* while the action is going on...
      state.loading = true;
    });
    builder.addCase(fetchPosts.fulfilled, (state, action) => {
      state.loading = false;
      // action.payload == response.data. Optional: try console.log(action.type) => "posts/fetchPosts"
      state.posts = action.payload;
    });
    builder.addCase(fetchPosts.rejected, (state, action) => {
      state.loading = false;
      state.posts = [];
      state.error = action.error.message as string;
    });

    builder.addCase(getProjectsBySearch.pending, (state) => {
      // With the help of this one we can set a *loader* while the action is going on...
      state.loading = true;
    });
    builder.addCase(getProjectsBySearch.fulfilled, (state, action) => {
      state.loading = false;
      // action.payload == response.data. Optional: try console.log(action.type) => "posts/fetchPosts"
      state.posts = action.payload;
    });
    builder.addCase(getProjectsBySearch.rejected, (state, action) => {
      state.loading = false;
      state.posts = [];
      state.error = action.error.message as string;
    });
  },
});

// Step 5: Default Export the reducer
export default postsSlice.reducer;

// Step 6: pass the reducer (which triggers state mutation) to the configureStore

// Step 7: Export the store and feed to it to the React component tree
